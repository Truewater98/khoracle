--5. 부서별 급여 평균이 3,000,000원(버림적용) 이상인  부서들에 대해서 부서명, 급여평균을 출력하세요.
SELECT DEPT_CODE, FLOOR(AVG(SALARY))
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING FLOOR(AVG(SALARY)) >= 3000000;

-- # HAVING절
-- 그룹함수는 값을 구해온 그룹에 대해 조건을 설정할 때는
-- HAVING절에 기술함 !! WHERE절은 사용불가!!!!!!!!!!

--@실습문제
--1. 부서별 인원이 5명보다 많은 부서와 인원수를 출력하세요.
SELECT DEPT_CODE, COUNT(*)
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING COUNT(*) > 5;

--2. 부서별내 직급별 인원수가 3명이상인 직급의 부서코드, 직급코드, 인원수를 출력하세요.
SELECT DEPT_CODE, JOB_CODE, COUNT(*)
FROM EMPLOYEE
GROUP BY DEPT_CODE, JOB_CODE
HAVING COUNT(JOB_CODE) >= 3
ORDER BY 1 ASC;
--3. 매니져가 관리하는 사원이 2명이상인 매니져아이디와 관리하는 사원수를 출력하세요.
SELECT MANAGER_ID, COUNT(*)
FROM EMPLOYEE
GROUP BY MANAGER_ID
HAVING COUNT(MANAGER_ID) >= 2
ORDER BY 1 ASC;


--# ROLLUP과 CUBE
SELECT JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY ROLLUP(JOB_CODE)
ORDER BY 1 ASC;

SELECT JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY CUBE(JOB_CODE)
ORDER BY 1 ASC;

SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY ROLLUP(DEPT_CODE, JOB_CODE)
ORDER BY 1 ASC;

SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY CUBE(DEPT_CODE, JOB_CODE)
ORDER BY 1 ASC;

-- 집합연산자
-- 교집합 --> INTERSECT
-- 합집합 --> UNION, UNION ALL
-- 차집합 --> MINUS
-- 교집합 연산
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE DEPT_CODE = 'D5'
INTERSECT
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE SALARY >= 2400000;
-- 합집합연산( 교집합 중복)
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE DEPT_CODE = 'D5'
UNION ALL
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE SALARY >= 2400000;
-- 합집합연산
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE DEPT_CODE = 'D5'
UNION
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE SALARY >= 2400000;
-- 차집합연산
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE DEPT_CODE = 'D5'
MINUS
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE SALARY >= 2400000;

-- ** UNION의 조건!!
-- 1. SELECT문의 컬럼 갯수가 반드시 같아야 함 ORA-01789: query block has incorrect number of result columns
-- 2. 컬럼의 데이터 타입이 받드시 같거나 변환가능해야함 (EX CHAR - VARCHAR2) ORA-01790: expression must have same datatype as corresponding expression
SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE DEPT_CODE = 'D5'
UNION
SELECT EMP_NAME, EMP_ID FROM EMPLOYEE WHERE SALARY >= 2400000;
-- # 조인문(JOIN)
-- -> 여러 테이블의 레코드를 조합하여 하나의 열로 표현한 것
-- -> 새로운 가상의 데이블을 이용하여 출력함
-- 서로 다른 테이블에서 각각의 공통값을 이용함으로서 필드를 조합함.
-- 다시말해, 서로 다른 테이블에서 각각의 공통값을 이용함으로서 필드를 조합함.

--11. 사원명과, 부서명을 출력하세요. *
--   부서코드가 D5이면 총무부, D6이면 기획부, D9이면 영업부로 처리하시오.(case 사용)
--   단, 부서코드가 D5, D6, D9 인 직원의 정보만 조회하고, 부서코드 기준으로 오름차순 정렬함.
SELECT EMP_NAME, DECODE(DEPT_CODE, 'D5', '총무부', 'D6', '기획부', 'D9', '영업부')
FROM EMPLOYEE
WHERE DEPT_CODE IN ('D5', 'D6', 'D9');
SELECT * FROM DEPARTMENT;

SELECT EMP_NAME, DEPT_CODE FROM EMPLOYEE;
SELECT DEPT_ID, DEPT_TITLE FROM DEPARTMENT;
-- # 조인문
-- SELECT 컬럼명 FROM 테이블 JOIN 테이블 ON 컬럼명1 = 컬럼명2
SELECT EMP_NAME, DEPT_TITLE FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;
-- ANSI 표준구문
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT WHERE DEPT_CODE = DEPT_ID;
-- 오라클 전용 구문

-- JOIN의 종류
-- 1. EQUI-JOIN : 일반적으로 사용, =에 의한 조인
-- 2. NON-EQUI JOIN : 동등조건이 아닌 BETWEEN AND, IS NULL, IS NOT NULL, IN , NOT IN 등으로 사용

-- @실습문제
--1. 부서명과 지역명을 출력하세요. DEPARTMENT, LOCATION 테이블 이용
SELECT DEPT_TITLE, LOCAL_NAME
FROM DEPARTMENT JOIN LOCATION ON LOCATION_ID = LOCAL_CODE;

--2. 사원명과 직급명을 출력하세요. EMPLOYEE, JOB 테이블 이용
-- 모호함 해결방법 1 : 컬럼앞에 테이블.
SELECT EMP_NAME, JOB_NAME
FROM EMPLOYEE JOIN JOB ON EMPLOYEE.JOB_CODE = JOB.JOB_CODE;
-- 모호함 해결방법 2 : 테이블 별칭
SELECT EMP_NAME, JOB_NAME
FROM EMPLOYEE E JOIN JOB J ON E.JOB_CODE = J.JOB_CODE;
-- 모호함 해결방법 3 : ON 대신 USING 사용
SELECT EMP_NAME, JOB_NAME
FROM EMPLOYEE E JOIN JOB J USING (JOB_CODE);

-- 3. 지역명과 국가명을 출력하세요. LOCATION, NATION 테이블 이용
SELECT LOCAL_NAME, NATIONAL_NAME
FROM LOCATION JOIN NATIONAL USING(NATIONAL_CODE);

-- ## INNER JOIN
-- ### INNER EQUI JOIN

-- ## JOIN의 종류 2
-- INNER JOIN(내부조인) : 일반적으로 사용하는 조인(교집합)
-- OUTER JOIN(외부조인) : 모두출력 (합집합)
-- -> 1. LEFT (OUTER) JOIN 
-- -> 2. RIGHT (OUTER) JOIN
-- -> 3. FULL (OUTER) JOIN
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE INNER JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;

SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE LEFT JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;
--ORACLE 전용 LEFT OUTER JOIN 구문
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT WHERE DEPT_CODE = DEPT_ID(+);

SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE RIGHT JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;
--ORACLE 전용 RIGHT OUTER JOIN 구문
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT WHERE DEPT_CODE(+) = DEPT_ID;

SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE FULL JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;


-- EX) OUTER JOIN(외부조인)을 살펴보자
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE LEFT JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;

SELECT EMP_NAME, DEPT_TITLE
FROM DEPARTMENT RIGHT JOIN EMPLOYEE ON DEPT_ID = DEPT_CODE;


-- ## JOIN의 종류3
-- 1. 상호조인(CROSS JOIN)
-- 2. 셀프조인(SELF JOIN)
-- 3. 다중조인
-- -> 여러 개의 조인문을 한번에 사용할 수 있음
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
JOIN LOCATION ON LOCATION_ID = LOCAL_CODE;
-- -> 순서가 중요하다!!

--@실습문제
-- 1. 직급이 대리이면서, ASIA 지역에 근무하는 직원 조회
-- 사번, 이름 ,직급명, 부서명, 근무지역명, 급여를 조회하시오
SELECT EMP_ID "사번", EMP_NAME "이름", JOB_NAME "직급명", DEPT_TITLE "부서명",LOCAL_NAME "근무지역명", SALARY "급여"
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE)
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
JOIN LOCATION ON LOCATION_ID = LOCAL_CODE
WHERE JOB_NAME = '대리' AND LOCAL_NAME LIKE 'ASIA%';

-- 제약조건 걸려있는 부모테이블 레코드 지워보기!
DELETE FROM USER_GRADE
WHERE GRADE_CODE = 10;
--ORA-02292: integrity constraint (KH.GRADE_CODE_PK) violated - child record found
--못지운다. 그런데 지우는 방법, 즉 삭제옵션이 2개 있다.
-- 1. ON DELETE SET NULL; -> 자식 테이블 데이터를 NULL로 바꿔줌
-- 2. ON DELETE CASCADE; -> 자식테이블 데이터도 지워줌
ALTER TABLE USER_FOREIGNKEY
DROP CONSTRAINT GRADE_CODE_FK;
COMMIT;
--커밋 완료.
ROLLBACK;
--롤백 완료.
ALTER TABLE USER_FOREIGNKEY
ADD CONSTRAINT GRADE_CODE_FK FOREIGN KEY (GRADE_CODE) REFERENCES USER_GRADE(GRADE_CODE)
ON DELETE SET NULL;

ALTER TABLE USER_FOREIGNKEY
ADD CONSTRAINT GRADE_CODE_FK FOREIGN KEY (GRADE_CODE) REFERENCES USER_GRADE(GRADE_CODE)
ON DELETE CASCADE;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE
FROM USER_CONSTRAINTS
WHERE TABLE_NAME='USER_FOREIGNKEY';
-- 세줄 요약
-- 1. 외래키(자식테이블)가 참조하는 부모테이블 컬럼 데이터는 기본적으로 지워지지 않는다.
-- 2. ON DELETE SET NULL 옵션은 부모테이블 데이터를 지워주고 자식테이블 데이터는 NULL로 해준다
-- 3. ON DELETE CASCADE 옵션은 부모테이블 데이터를 지워주고 자식테이블 데이터도 지워준다
SELECT * FROM USER_FOREIGNKEY;

--@조인실습문제_kh
--1. 2022년 12월 25일이 무슨 요일인지 조회하시오.
SELECT TO_CHAR(TO_DATE('2022/12/25'), 'DAY') FROM DUAL; 
--2. 주민번호가 1970년대 생이면서 성별이 여자이고, 성이 전씨인 직원들의 사원명, 주민번호, 부서명, 직급명을 조회하시오.
SELECT EMP_NAME "사원명", EMP_NO "주민번호", DEPT_TITLE "부서명", JOB_NAME "직급명"
FROM EMPLOYEE
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
JOIN JOB USING (JOB_CODE)
WHERE SUBSTR(EMP_NO, 1, 2) BETWEEN 70 AND 79 AND SUBSTR(EMP_NO,8,1) IN ('2','4') AND EMP_NAME LIKE '전%';
--3. 이름에 '형'자가 들어가는 직원들의 사번, 사원명, 부서명을 조회하시오.
SELECT EMP_ID "사번", EMP_NAME "사원명", DEPT_TITLE "부서명"
FROM EMPLOYEE
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
WHERE EMP_NAME LIKE '%형%';
--4. 해외영업부에 근무하는 사원명, 직급명, 부서코드, 부서명을 조회하시오.
SELECT EMP_NAME "사원명", JOB_NAME "직급명", DEPT_CODE "부서코드", DEPT_TITLE "부서명"
FROM EMPLOYEE
JOIN JOB USING (JOB_CODE)
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
WHERE DEPT_TITLE LIKE '해외영업_부%';
--5. 보너스포인트를 받는 직원들의 사원명, 보너스포인트, 부서명, 근무지역명을 조회하시오.
SELECT EMP_NAME "사원명", NVL(BONUS, 0) "보너스포인트", DEPT_TITLE "부서명", LOCAL_NAME "근무지역명"
FROM EMPLOYEE
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
JOIN LOCATION ON LOCATION_ID = LOCAL_CODE
WHERE BONUS IS NOT NULL;
--6. 부서코드가 D2인 직원들의 사원명, 직급명, 부서명, 근무지역명을 조회하시오.
SELECT EMP_NAME "사원명", JOB_NAME "직급명", DEPT_TITLE "부서명", LOCAL_NAME "근무지역명"
FROM EMPLOYEE
JOIN DEPARTMENT ON DEPT_ID = DEPT_CODE
JOIN JOB USING(JOB_CODE)
JOIN LOCATION ON LOCAL_CODE = LOCATION_ID
WHERE DEPT_CODE = 'D2';
--7. 급여등급테이블의 최대급여(MAX_SAL)보다 많이 받는 직원들의 사원명, 직급명, 급여, 연봉을 조회하시오.
-- (사원테이블과 급여등급테이블을 SAL_LEVEL컬럼기준으로 조인할 것)
SELECT EMP_NAME "사원명", JOB_NAME "직급명", SALARY "급여", SALARY * 12 "연봉"
FROM EMPLOYEE
JOIN SAL_GRADE USING(SAL_LEVEL)
JOIN JOB USING (JOB_CODE)
WHERE MAX_SAL < SALARY;
--8. 한국(KO)과 일본(JP)에 근무하는 직원들의 사원명, 부서명, 지역명, 국가명을 조회하시오.
SELECT EMP_NAME "사원명", DEPT_TITLE "부서명", LOCAL_NAME "지역명", NATIONAL_NAME "국가명"
FROM EMPLOYEE
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
JOIN LOCATION ON LOCATION_ID = LOCAL_CODE
JOIN NATIONAL USING (NATIONAL_CODE)
WHERE NATIONAL_NAME IN ('한국','일본');
--9. 보너스포인트가 없는 직원들 중에서 직급이 차장과 사원인 직원들의 사원명, 직급명, 급여를 조회하시오. 단, join과 IN 사용할 것
SELECT EMP_NAME "사원명", JOB_NAME "직급명", SALARY "급여"
FROM EMPLOYEE
JOIN JOB USING (JOB_CODE)
WHERE BONUS IS NULL AND JOB_NAME IN ('차장', '사원');
--10. 재직중인 직원과 퇴사한 직원의 수를 조회하시오.
SELECT DECODE(ENT_YN,'Y','퇴직', 'N' , '재직') "근속여부" ,COUNT(*)
FROM EMPLOYEE
GROUP BY DECODE(ENT_YN,'Y','퇴직', 'N' , '재직');

CREATE TABLE TBL_SALES
(SALE_DATE   DATE  DEFAULT  SYSDATE --!디폴트값을 지정해 줄수 있나보다.
,P_NAME    VARCHAR2(20)
,P_COUNT     NUMBER
);
DROP TABLE TBL_SALES;

INSERT INTO TBL_SALES VALUES( ADD_MONTHS(SYSDATE, -2), '새우깡', 10);
INSERT INTO TBL_SALES VALUES( ADD_MONTHS(SYSDATE, -2)+1, '새우깡', 15);
INSERT INTO TBL_SALES VALUES( ADD_MONTHS(SYSDATE, -2)+2, '감자깡', 20);
INSERT INTO TBL_SALES VALUES( ADD_MONTHS(SYSDATE, -2)+3, '새우깡', 10);

INSERT INTO TBL_SALES VALUES( ADD_MONTHS(SYSDATE, -1), '고구마깡', 10);
INSERT INTO TBL_SALES VALUES( ADD_MONTHS(SYSDATE, -1)+1, '새우깡', 15);
INSERT INTO TBL_SALES VALUES( ADD_MONTHS(SYSDATE, -1)+2, '감자깡', 20);
INSERT INTO TBL_SALES VALUES( ADD_MONTHS(SYSDATE, -1)+3, '감자깡', 10);

INSERT INTO TBL_SALES VALUES( SYSDATE - 4, '허니버터칩', 30);
INSERT INTO TBL_SALES VALUES( SYSDATE - 3, '고구마깡', 15);
INSERT INTO TBL_SALES VALUES( SYSDATE - 2, '고구마깡', 10);
INSERT INTO TBL_SALES VALUES( SYSDATE - 1, '허니버터칩', 20);
INSERT INTO TBL_SALES VALUES( SYSDATE, '새우깡', 5);
INSERT INTO TBL_SALES VALUES( SYSDATE, '감자깡', 7);

INSERT INTO TBL_SALES VALUES( SYSDATE, '새우깡', 5);
INSERT INTO TBL_SALES VALUES( SYSDATE, '새우깡', 15);
INSERT INTO TBL_SALES VALUES( SYSDATE, '고구마깡', 10);

INSERT INTO TBL_SALES VALUES( SYSDATE, '고구마깡', 20);
INSERT INTO TBL_SALES VALUES( SYSDATE, '허니버터칩', 15);
INSERT INTO TBL_SALES VALUES( SYSDATE, '허니버터칩', 10);
INSERT INTO TBL_SALES VALUES( SYSDATE, '고구마깡', 5);

INSERT INTO TBL_SALES VALUES( SYSDATE, '새우깡', 10);

--2달전의 월에 판매 내역보기
--지난달 판매내역보기
--이번달 판매내역보기

--## 테이블 쪼개기
--테이블을 쪼개서 사용하는 경우가 많다. 실제 필요한 것은 당월인 경우가 많고, 
--지난 월들은 시간이 지남에 따라 보통 참조하지 않는다.
--기본 테이블에서 당월 데이터만 유지하고, 
--지난월은 따로 테이블로 생성해서 보관하다 필요시에 합쳐서 열람. 

--1. TBL_SALES_1801 테이블 추출 및 복제
CREATE TABLE TBL_SALES_1801
AS
SELECT *
FROM TBL_SALES
WHERE TO_CHAR(ADD_MONTHS(SYSDATE, -1), 'yyyy-mm') = TO_CHAR(SALE_DATE,'yyyy-mm');

SELECT * FROM TBL_SALES_1801;

--2. TBL_SALES_1801 해당정보 삭제 
DELETE FROM TBL_SALES
WHERE TO_CHAR(ADD_MONTHS(SYSDATE, -1), 'YYYY-MM') = TO_CHAR(SALE_DATE,'YYYY-MM');

COMMIT;

--1. TBL_SALES_1712 테이블 추출 및 복제
CREATE TABLE TBL_SALES_1712
AS
SELECT *
FROM TBL_SALES
WHERE TO_CHAR(ADD_MONTHS(SYSDATE, -2), 'yyyy-mm') = TO_CHAR(SALE_DATE,'yyyy-mm');

SELECT * FROM TBL_SALES_1712;

--2. TBL_SALES_1712 해당정보 삭제 
DELETE FROM TBL_SALES
WHERE TO_CHAR(ADD_MONTHS(SYSDATE, -2), 'yyyy-mm') = TO_CHAR(SALE_DATE,'yyyy-mm');

COMMIT;

-- 지난 3개월의 판매내역을 출력하세요.
-- 월별로 제품별 총 판매량을 출력하세요.